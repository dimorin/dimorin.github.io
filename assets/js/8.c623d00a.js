(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{189:function(t,e,s){"use strict";s.r(e);var r=s(0),n=Object(r.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),s("p",[t._v("ES5에서는 생성자 함수와 프로토타입을 사용하여 객체 지향 프로그래밍을 구현하였다.")]),t._v(" "),t._m(1),t._m(2),t._v(" "),t._m(3),t._m(4),t._v(" "),s("p",[t._v("표현식이 아닌 선언식으로 정의한 클래스의 이름은 constructor와 동일하다.")]),t._v(" "),t._m(5),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),s("p",[t._v("constructor는 인스턴스의 생성과 동시에 클래스 프로퍼티의 생성과 초기화를 실행한다.")]),t._v(" "),t._m(10),t._m(11),t._v(" "),s("p",[t._v("클래스 몸체(class body)에는 메소드만 선언할 수 있다. 클래스 바디에 클래스 프로퍼티(인스턴스 필드, 멤버 변수)를 선언하면 문법 에러(SyntaxError)가 발생한다.\n클래스 프로퍼티의 선언과 초기화는 반드시 constructor 내부에서 실시한다.")]),t._v(" "),t._m(12),t._m(13),t._v(" "),t._m(14),t._v(" "),s("p",[t._v("class 선언문 이전에 클래스를 참조하면 참조 에러(ReferenceError)가 발생한다.")]),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),s("p",[t._v("정적 메소드는 "),s("a",{attrs:{href:"https://poiemaweb.com/js-math",target:"_blank",rel:"noopener noreferrer"}},[t._v("Math"),s("OutboundLink")],1),t._v(" 객체의 메소드처럼 애플리케이션 전역에서 사용할 유틸리티(utility) 함수를 생성할 때 주로 사용한다.")]),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),s("p",[t._v("① super 메소드는 자식 class의 constructor 내부에서 부모 클래스의 constructor(super-constructor)를 호출한다.\n즉, 부모 클래스의 인스턴스를 생성한다.\n자식 클래스의 constructor에서 super()를 호출하지 않으면 this에 대한 참조 에러(ReferenceError)가 발생한다.\n② super 키워드는 부모 클래스(Base Class)에 대한 참조이다. 부모 클래스의 프로퍼티 또는 메소드를 참조하기 위해 사용한다.")]),t._v(" "),t._m(32),t._v(" "),s("p",[t._v("프로토타입 관점에서 바라보면 자식 클래스의 [[Prototype]] 프로퍼티가 가리키는 프로토타입 객체는 부모 클래스이다.")]),t._v(" "),t._m(33),s("p",[s("a",{attrs:{href:"https://poiemaweb.com/js-prototype#4-prototype-chain",target:"_blank",rel:"noopener noreferrer"}},[t._v("Prototype chain"),s("OutboundLink")],1),t._v("에 의해 부모 클래스의 정적 메소드도 상속된다.")]),t._v(" "),t._m(34),s("p",[t._v("자식 클래스의 정적 메소드 내부에서도 super 키워드를 사용하여 부모 클래스의 정적 메소드를 호출할 수 있다. 이는 자식 클래스는 프로토타입 체인에 의해 부모 클래스의 정적 메소드를 참조할 수 있기 때문이다.")]),t._v(" "),s("p",[t._v("하지만 자식 클래스의 일반 메소드(프로토타입 메소드) 내부에서는 super 키워드를 사용하여 부모 클래스의 정적 메소드를 호출할 수 없다. 이는 자식 클래스의 인스턴스는 프로토타입 체인에 의해 부모 클래스의 정적 메소드를 참조할 수 없기 때문이다.")]),t._v(" "),t._m(35)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"클래스"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#클래스","aria-hidden":"true"}},[this._v("#")]),this._v(" 클래스")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// ES5  \nvar  Person  =  (function  ()  {  \n\t// Constructor  \n\tfunction  Person(name)  {  \n\t\tthis._name  =  name;  \n\t}  \n\t// public method  \n\tPerson.prototype.sayHi  =  function  ()  {\n\t\tconsole.log('Hi! '  +  this._name);  \n\t};  \n\t// return constructor  \n\treturn  Person;  \n}());  \nvar  me  =  new  Person('Lee');  \nme.sayHi();  // Hi! Lee.  \nconsole.log(me  instanceof  Person);  // true\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"클래스-정의-class-definition"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#클래스-정의-class-definition","aria-hidden":"true"}},[this._v("#")]),this._v(" 클래스 정의(Class Definition)")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("class  Person  {  \n\tconstructor(name)  {  \n\t\tthis._name  =  name;  \n\t}  \n\tsayHi()  {  \n\t\tconsole.log(`Hi! ${this._name}`);  \n\t}  \n}  \nconst  me  =  new  Person('Lee');  \nme.sayHi();  // Hi! Lee  \nconsole.log(me  instanceof  Person);  // true\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"인스턴스의-생성"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#인스턴스의-생성","aria-hidden":"true"}},[this._v("#")]),this._v(" 인스턴스의 생성")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("class  Foo  {}  \nconst  foo  =  new  Foo();\nconsole.log(Foo  ===  Foo.prototype.constructor);  // true\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"constructor"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#constructor","aria-hidden":"true"}},[this._v("#")]),this._v(" constructor")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("constructor")]),this._v("는 인스턴스를 생성하고 클래스 프로퍼티를 초기화하기 위한 특수한 메소드이다. constructor는 클래스 내에 한 개만 존재할 수 있으며 만약 클래스가 2개 이상의 constructor를 포함하면 문법 에러(SyntaxError)가 발생한다. 인스턴스를 생성할 때 new 연산자와 함께 호출한 것이 바로 constructor이며 constructor의 파라미터에 전달한 값은 클래스 프로퍼티에 할당한다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("constructor는 생략할 수 있다. constructor를 생략하면 클래스에  "),e("code",[this._v("constructor() {}")]),this._v("를 포함한 것과 동일하게 동작한다. 즉, 빈 객체를 생성한다. 따라서 클래스 프로퍼티를 선언하려면 인스턴스를 생성한 이후, 클래스 프로퍼티를 동적 할당해야 한다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("class  Foo  {  }  \nconst  foo  =  new  Foo();  \nconsole.log(foo);  // Foo {}  \n// 클래스 프로퍼티의 동적 할당 및 초기화  \nfoo.num  =  1;  \nconsole.log(foo);  // Foo&nbsp;{ num: 1 }\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("class  Foo  {  \n\t// constructor는 인스턴스의 생성과 동시에 클래스 프로퍼티의 생성과 초기화를 실행한다.  \n\tconstructor(num)  {  \n\t\tthis.num  =  num;  \n\t}  \n}  \nconst  foo  =  new  Foo(1);  \nconsole.log(foo);  // Foo { num: 1 }\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"클래스-프로퍼티"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#클래스-프로퍼티","aria-hidden":"true"}},[this._v("#")]),this._v(" 클래스 프로퍼티")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("class  Foo  {  \n\tconstructor(name  =  '')  {  \n\t\tthis.name  =  name;  // 클래스 프로퍼티의 선언과 초기화  \n\t}  \n\tname  =  '';  // SyntaxError\n}  \nconst  foo  =  new  Foo('Lee');  \nconsole.log(foo);  // Foo { name: 'Lee' }\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("constructor 내부에서 선언한 클래스 프로퍼티는 클래스의 인스턴스를 가리키는 "),e("strong",[this._v("this")]),this._v("에 바인딩한다. 이로써 클래스 프로퍼티는 클래스가 생성할 인스턴스의 프로퍼티가 되며, 클래스의 인스턴스를 통해 클래스 외부에서 언제나 참조할 수 있다. 즉, 언제나 "),e("code",[this._v("public")]),this._v("이다.\nES6의 클래스는 다른 객체지향 언어처럼 private, public, protected 키워드와 같은 접근 제한자(access modifier)를 지원하지 않는다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"호이스팅"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#호이스팅","aria-hidden":"true"}},[this._v("#")]),this._v(" 호이스팅")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"getter-setter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#getter-setter","aria-hidden":"true"}},[this._v("#")]),this._v(" getter, setter")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"getter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#getter","aria-hidden":"true"}},[this._v("#")]),this._v(" getter")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("getter는 클래스 프로퍼티에 접근할 때마다 클래스 프로퍼티의 값을 조작하는 행위가 필요할 때 사용한다. getter는 메소드 이름 앞에 "),e("code",[this._v("get")]),this._v(" 키워드를 사용해 정의한다. 이때 메소드 이름은 클래스 프로퍼티 이름처럼 사용된다. 다시 말해 getter는 호출하는 것이 아니라 프로퍼티처럼 참조하는 형식으로 사용하며 참조 시에 메소드가 호출된다. getter는 이름 그대로 무언가를 취득할 때 사용하므로 반드시 무언가를 반환해야 한다. 사용 방법은 아래와 같다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("class  Foo  {  \n\tconstructor(arr  =  [])  {  \n\t\tthis._arr  =  arr;  \n\t}  \n\t// getter: get 키워드 뒤에 오는 메소드 이름 firstElem은 프로퍼티 이름처럼 사용된다.  \n\tget  firstElem()  {  \n\t\t// getter는 반드시 무언가를 반환해야 한다.  \n\t\treturn  this._arr.length  ?  this._arr[0]  :  null;  \n\t}  \n}  \nconst  foo  =  new  Foo([1,  2]);  \n// 프로퍼티 firstElem에 접근하면 getter가 호출된다.  \nconsole.log(foo.firstElem);  // 1\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"setter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#setter","aria-hidden":"true"}},[this._v("#")]),this._v(" setter")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("setter는 클래스 프로퍼티에 값을 할당할 때마다 클래스 프로퍼티의 값을 조작하는 행위가 필요할 때 사용한다. setter는 메소드 이름 앞에 "),e("code",[this._v("set")]),this._v(" 키워드를 사용해 정의한다. 이때 메소드 이름은 클래스 프로퍼티 이름처럼 사용된다. 다시 말해 setter는 호출하는 것이 아니라 프로퍼티처럼 값을 할당하는 형식으로 사용하며 할당 시에 메소드가 호출된다. 사용 방법은 아래와 같다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("class  Foo  {  \n\tconstructor(arr  =  [])  {  \n\t\tthis._arr  =  arr;  \n\t}  \n\t// getter: get 키워드 뒤에 오는 메소드 이름 firstElem은 프로퍼티 이름처럼 사용된다.  \n\tget  firstElem()  {  \n\t// getter는 반드시 무언가를 반환하여야 한다.  \n\t\treturn  this._arr.length  ?  this._arr[0]  :  null;  \n\t}  \n\t// setter: set 키워드 뒤에 오는 메소드 이름 firstElem은 프로퍼티 이름처럼 사용된다.  \n\tset  firstElem(elem)  {  \n\t\t// ...this._arr은 this._arr를 개별 요소로 분리한다  \n\t\tthis._arr  =  [elem,  ...this._arr];  \n\t}  \n}  \nconst  foo  =  new  Foo([1,  2]);  \n// 프로퍼티 lastElem에 값을 할당하면 setter가 호출된다.  \nfoo.firstElem  =  100;  \nconsole.log(foo.firstElem);  // 100\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"정적-메소드"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#정적-메소드","aria-hidden":"true"}},[this._v("#")]),this._v(" 정적 메소드")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("클래스의 정적(static) 메소드를 정의할 때 "),e("strong",[this._v("static")]),this._v(" 키워드를 사용한다. 정적 메소드는 클래스의 인스턴스가 아닌 클래스 이름으로 호출한다. 따라서 클래스의 인스턴스를 생성하지 않아도 호출할 수 있다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("class  Foo  {  \n\tconstructor(prop)  {  \n\t\tthis.prop  =  prop;  \n\t}  \n\tstatic  staticMethod()  {  \n\t\t/*  정적 메소드는 this를 사용할 수 없다.  정적 메소드 내부에서 this는 클래스의 인스턴스가 아닌 클래스 자신을 가리킨다.  */  \n\t\treturn  'staticMethod';  \n\t}  \n\tprototypeMethod()  {  \n\t\treturn  this.prop;  \n\t}  \n}  \n// 정적 메소드는 클래스 이름으로 호출한다.  \nconsole.log(Foo.staticMethod());  \nconst  foo  =  new  Foo(123);  \n// 정적 메소드는 인스턴스로 호출할 수 없다.  \nconsole.log(foo.staticMethod());  // Uncaught TypeError: foo.staticMethod is not a function\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"클래스-상속"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#클래스-상속","aria-hidden":"true"}},[this._v("#")]),this._v(" 클래스 상속")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"extends-키워드"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#extends-키워드","aria-hidden":"true"}},[this._v("#")]),this._v(" extends 키워드")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("extends")]),this._v(" 키워드는 부모 클래스(base class)를 상속받는 자식 클래스(sub class)를 정의할 때 사용한다. 부모 클래스 Circle을 상속받는 자식 클래스 Cylinder를 정의해 보자.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// 부모 클래스  \nclass  Circle  {  \n\tconstructor(radius)  {  \n\t\tthis.radius  =  radius;  // 반지름  \n\t}  \n\t// 원의 지름  \n\tgetDiameter()  {  \n\t\treturn  2  *  this.radius;  \n\t}  \n\t// 원의 둘레  \n\tgetPerimeter()  {  \n\t\treturn  2  *  Math.PI  *  this.radius;  \n\t}  \n\t// 원의 넓이  \n\tgetArea()  {  \n\t\treturn  Math.PI  *  Math.pow(this.radius,  2);  \n\t}  \n}  \n// 자식 클래스  \nclass  Cylinder  extends  Circle  {  \n\tconstructor(radius,  height)  {  \n\t\tsuper(radius);  \n\t\tthis.height  =  height;  \n\t}  \n\t// 원통의 넓이: 부모 클래스의 getArea 메소드를 오버라이딩하였다.  \n\tgetArea()  {  \n\t\t// (원통의 높이 * 원의 둘레) + (2 * 원의 넓이)\n\t  return  (this.height  *  super.getPerimeter())  +  (2  *  super.getArea());  \n  }  \n  // 원통의 부피  \n  getVolume()  {  \n\t  return  super.getArea()  *  this.height;  \n  }  \n}  \n// 반지름이 2, 높이가 10인 원통  \nconst  cylinder  =  new  Cylinder(2,  10);  \n// 원의 지름  \nconsole.log(cylinder.getDiameter());  // 4  \n// 원의 둘레  \nconsole.log(cylinder.getPerimeter());  // 12.566370614359172  \n// 원통의 넓이  \nconsole.log(cylinder.getArea());  // 150.79644737231007  \n// 원통의 부피  \nconsole.log(cylinder.getVolume());  // 125.66370614359172  \n// cylinder는 Cylinder 클래스의 인스턴스이다.  \nconsole.log(cylinder  instanceof  Cylinder);  // true  \n// cylinder는 Circle 클래스의 인스턴스이다.  \nconsole.log(cylinder  instanceof  Circle);  // true\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"super-키워드"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#super-키워드","aria-hidden":"true"}},[this._v("#")]),this._v(" super 키워드")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("super 키워드는 부모 클래스를 참조(reference) 할 때 또는 부모 클래스의 constructor를 호출할 때 사용한다.")]),this._v("\nsuper가 메소드로 사용될 때, 그리고 객체로 사용될 때 다르게 동작한다.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// 부모 클래스\nclass Circle {\n...\n}\nclass Cylinder extends Circle {\n  constructor(radius, height) {\n    // ① super 메소드는 부모 클래스의 인스턴스를 생성\n    super(radius);\n    this.height = height;\n  }\n  // 원통의 넓이: 부모 클래스의 getArea 메소드를 오버라이딩하였다.\n  getArea() {\n    // (원통의 높이 * 원의 둘레) + (2 * 원의 넓이)\n    // ② super 키워드는 부모 클래스(Base Class)에 대한 참조\n    return (this.height * super.getPerimeter()) + (2 * super.getArea());\n  }\n  // 원통의 부피\n  getVolume() {\n    // ② super 키워드는 부모 클래스(Base Class)에 대한 참조\n    return super.getArea() * this.height;\n  }\n}\n// 반지름이 2, 높이가 10인 원통\nconst cylinder = new Cylinder(2, 10);\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"static-메소드와-prototype-메소드의-상속"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#static-메소드와-prototype-메소드의-상속","aria-hidden":"true"}},[this._v("#")]),this._v(" static 메소드와 prototype 메소드의 상속")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("class Parent {}\nclass Child extends Parent {}\nconsole.log(Child.__proto__ === Parent); // true\nconsole.log(Child.prototype.__proto__ === Parent.prototype); // true\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("class Parent {\n  static staticMethod() {\n    return 'staticMethod';\n  }\n}\nclass Child extends Parent {}\nconsole.log(Parent.staticMethod()); // 'staticMethod'\nconsole.log(Child.staticMethod());  // 'staticMethod'\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("class Parent {\n  static staticMethod() {\n    return 'Hello';\n  }\n}\nclass Child extends Parent {\n  static staticMethod() {\n    return `${super.staticMethod()} wolrd`;\n  }\n  prototypeMethod() {\n    return `${super.staticMethod()} wolrd`;\n  }\n}\nconsole.log(Parent.staticMethod()); // 'Hello'\nconsole.log(Child.staticMethod());  // 'Hello wolrd'\nconsole.log(new Child().prototypeMethod());\n// TypeError: (intermediate value).staticMethod is not a function\n")])])])}],!1,null,null,null);e.default=n.exports}}]);