(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{190:function(t,n,e){"use strict";e.r(n);var a=e(0),s=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"화살표-함수"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#화살표-함수","aria-hidden":"true"}},[t._v("#")]),t._v(" 화살표 함수")]),t._v(" "),e("h2",{attrs:{id:"화살표-함수의-선언"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#화살표-함수의-선언","aria-hidden":"true"}},[t._v("#")]),t._v(" 화살표 함수의 선언")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 매개변수 지정 방법  \n()  =>  {  ...  }  // 매개변수가 없을 경우  \nx  =>  {  ...  }  // 매개변수가 한 개인 경우, 소괄호를 생략할 수 있다.  \n(x,  y)  =>  {  ...  }  // 매개변수가 여러 개인 경우, 소괄호를 생략할 수 없다.  \n// 함수 몸체 지정 방법  \nx  =>  {  return  x  *  x  }  // single line block\nx  =>  x  *  x  // 함수 몸체가 한줄의 구문이라면 중괄호를 생략할 수 있으며 암묵적으로 return된다. 위 표현과 동일하다.  \n()  =>  {  return  {  a:  1  };  }  \n()  =>  ({  a:  1  })  // 위 표현과 동일하다. 객체 반환시 소괄호를 사용한다.  \n()  =>  {  // multi line block.  \n\tconst  x  =  10;  \n\treturn  x  *  x;  \n};\n")])])]),e("h2",{attrs:{id:"화살표-함수의-호출"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#화살표-함수의-호출","aria-hidden":"true"}},[t._v("#")]),t._v(" 화살표 함수의 호출")]),t._v(" "),e("p",[t._v("화살표 함수는 익명 함수로만 사용할 수 있다. 따라서 화살표 함수를 호출하기 위해서는 함수 표현식을 사용한다.")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// ES5  \nvar  pow  =  function  (x)  {  return  x  *  x;  };  \nconsole.log(pow(10));  // 100\n// ES6  \nconst  pow  =  x  =>  x  *  x;  \nconsole.log(pow(10));  // 100\n")])])]),e("p",[t._v("\n콜백 함수로 사용할 수 있다. 이 경우 일반적인 함수 표현식보다 표현이 간결하다.\n")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// ES5  \nvar  arr  =  [1,  2,  3];  \nvar  pow  =  arr.map(function  (x)  {  // x는 요소값  \n\treturn  x  *  x;  \n});  \nconsole.log(pow);  // [ 1, 4, 9 ]\n// ES6  \nconst  arr  =  [1,  2,  3];  \nconst  pow  =  arr.map(x  =>  x  *  x);  console.log(pow);  // [ 1, 4, 9 ]\n")])])]),e("h2",{attrs:{id:"this"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this","aria-hidden":"true"}},[t._v("#")]),t._v(" this")]),t._v(" "),e("p",[t._v("function 키워드로 생성한 일반 함수와 화살표 함수의 가장 큰 차이점은 this이다.")]),t._v("\n1. 일반 함수의 this\n\t- 콜백함수 내부의 this는 전역객체 window를 가리킨다."),e("br"),t._v("\n2. 화살표 함수의 this\n\t- 화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정된다. 동적으로 결정되는 일반 함수와는 달리 **화살표 함수의 this 언제나 상위 스코프의 this를 가리킨다.** 이를 **Lexical this**라 한다. \n"),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function  Prefixer(prefix)  {  \n\tthis.prefix  =  prefix;  \n}  \nPrefixer.prototype.prefixArray  =  function  (arr)  {  \n// this는 상위 스코프인 prefixArray 메소드 내의 this를 가리킨다.  \n\treturn  arr.map(x  =>  `${this.prefix}  ${x}`);  \n};  \nconst  pre  =  new  Prefixer('Hi');  \nconsole.log(pre.prefixArray(['Lee',  'Kim']));\n")])])]),e("p",[t._v("화살표 함수는 call, applay, bind 메소드를 사용하여 this를 변경할 수 없다.")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("window.x  =  1;  \nconst  normal  =  function  ()  {  return  this.x;  };  \nconst  arrow  =  ()  =>  this.x;  \nconsole.log(normal.call({  x:  10  }));  // 10  \nconsole.log(arrow.call({  x:  10  }));  // 1\n")])])]),e("h2",{attrs:{id:"화살표-함수를-사용해서는-안되는-경우"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#화살표-함수를-사용해서는-안되는-경우","aria-hidden":"true"}},[t._v("#")]),t._v(" 화살표 함수를 사용해서는 안되는 경우")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("메소드")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// Bad  \nconst  person  =  {  \n\tname:  'Lee',  \n\tsayHi:  ()  =>  console.log(`Hi ${this.name}`)  \n};  \nperson.sayHi();  // Hi undefined\n// Good  \nconst  person  =  {  \n\tname:  'Lee',  \n\tsayHi()  {  // === sayHi: function() {  \n\t\tconsole.log(`Hi ${this.name}`);  \n\t}  \n};  \nperson.sayHi();  // Hi Lee\n")])])]),e("p",[t._v("메소드로 정의한 화살표 함수 내부의 this는 메소드를 소유한 객체, 즉 메소드를 호출한 객체를 가리키지 않고 상위 컨택스트인 전역 객체 window를 가리킨다. 따라서 화살표 함수로 메소드를 정의하는 것은 바람직하지 않다.")])]),t._v(" "),e("li",[e("p",[t._v("prototype")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// Bad  \nconst  person  =  {  \n\tname:  'Lee',  \n};  \nObject.prototype.sayHi  =  ()  =>  console.log(`Hi ${this.name}`);  \nperson.sayHi();  // Hi undefined\n// Good  \nconst  person  =  {  \n\tname:  'Lee',  \n};  \nObject.prototype.sayHi  =  function()  {  \n\tconsole.log(`Hi ${this.name}`);  \n};  \nperson.sayHi();  // Hi Lee\n")])])])]),t._v(" "),e("li",[e("p",[t._v("생성자 함수\n화살표 함수는 생성자 함수로 사용할 수 없다. 생성자 함수는 prototype 프로퍼티를 가지며 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor를 사용한다. 하지만 화살표 함수는 prototype 프로퍼티를 가지고 있지 않다.")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const  Foo  =  ()  =>  {};  \n// 화살표 함수는 prototype 프로퍼티가 없다  \nconsole.log(Foo.hasOwnProperty('prototype'));  // false  \nconst  foo  =  new  Foo();  // TypeError: Foo is not a constructor\n")])])])]),t._v(" "),e("li",[e("p",[t._v("addEventListener 함수의 콜백 함수\naddEventListener 함수의 콜백 함수를 화살표 함수로 정의하면 this가 상위 컨택스트인 전역 객체 window를 가리킨다.")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// Bad  \nvar  button  =  document.getElementById('myButton');  \nbutton.addEventListener('click',  ()  =>  { \n\tconsole.log(this  ===  window);  // => true  \n\tthis.innerHTML  =  'Clicked button';  \n});\n// Good  \nvar  button  =  document.getElementById('myButton');  \nbutton.addEventListener('click',  function()  {  \n\tconsole.log(this  ===  button);  // => true  \n\tthis.innerHTML  =  'Clicked button';  \n});\n")])])])])])])}],!1,null,null,null);n.default=s.exports}}]);