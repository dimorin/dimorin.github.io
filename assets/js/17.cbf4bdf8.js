(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{180:function(o,t,e){"use strict";e.r(t);var l=e(0),a=Object(l.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var o=this,t=o.$createElement,e=o._self._c||t;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"_7번째-타입-심볼-symbol"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7번째-타입-심볼-symbol","aria-hidden":"true"}},[o._v("#")]),o._v(" 7번째 타입 심볼(Symbol)")]),o._v(" "),e("h2",{attrs:{id:"symbol이란"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#symbol이란","aria-hidden":"true"}},[o._v("#")]),o._v(" Symbol이란?")]),o._v(" "),e("p",[o._v("1997년 자바스크립트가 ECMAScript로 처음 표준화된 이래로 자바스크립트는 6개의 타입을 가지고 있었다.")]),o._v(" "),e("ul",[e("li",[o._v("원시 타입 (primitive data type)\n"),e("ul",[e("li",[o._v("Boolean")]),o._v(" "),e("li",[o._v("null")]),o._v(" "),e("li",[o._v("undefined")]),o._v(" "),e("li",[o._v("Number")]),o._v(" "),e("li",[o._v("String")])])]),o._v(" "),e("li",[o._v("객체 타입 (Object type)\n"),e("ul",[e("li",[o._v("Object")])])])]),o._v(" "),e("p",[o._v("심볼(symbol)은 ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다.\n심볼은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해 사용한다.")]),o._v(" "),e("h2",{attrs:{id:"symbol의-생성"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#symbol의-생성","aria-hidden":"true"}},[o._v("#")]),o._v(" Symbol의 생성")]),o._v(" "),e("p",[o._v("Symbol은 Symbol() 함수로 생성한다. Symbol() 함수는 호출될 때마다 Symbol 값을 생성한다. 이때 생성된 Symbol은 객체가 아니라 변경 불가능한 원시 타입의 값이다.")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("// 심볼 mySymbol은 이름의 충돌 위험이 없는 유일한 프로퍼티 키\nlet mySymbol = Symbol();\nconsole.log(mySymbol);        // Symbol()\nconsole.log(typeof mySymbol); // symbol\n")])])]),e("p",[o._v("Symbol() 함수는 String, Number, Boolean과 같이 래퍼 객체를 생성하는 생성자 함수와는 달리 new 연산자를 사용하지 않는다.")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("new Symbol(); // TypeError: Symbol is not a constructor\n")])])]),e("p",[o._v("Symbol() 함수에는 문자열을 인자로 전달할 수 있다. 이 문자열은 Symbol 생성에 어떠한 영향을 주지 않으며 다만 생성된 Symbol에 대한 설명(description)으로 디버깅 용도로만 사용된다.")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("let symbolWithDesc = Symbol('ungmo2');\nconsole.log(symbolWithDesc); // Symbol(ungmo2)\nconsole.log(symbolWithDesc === Symbol('ungmo2')); // false\n")])])]),e("h2",{attrs:{id:"symbol의-사용"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#symbol의-사용","aria-hidden":"true"}},[o._v("#")]),o._v(" Symbol의 사용")]),o._v(" "),e("p",[o._v("객체의 프로퍼티 키는 빈 문자열을 포함하는 모든 문자열로 만들 수 있다.")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("const obj = {};\nobj.prop = 'myProp';\nobj[123] = 123; // 123은 문자열로 변환된다.\n// obj.123 = 123;  // SyntaxError: Unexpected number\nobj['prop' + 123] = false;\nconsole.log(obj); // { '123': 123, prop: 'myProp', prop123: false }\n")])])]),e("p",[o._v("Symbol 값도 객체의 프로퍼티 키로 사용할 수 있다. Symbol 값은 유일한 값이므로 Symbol 값을 키로 갖는 프로퍼티는 다른 어떠한 프로퍼티와도 충돌하지 않는다.")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("const obj = {};\nconst mySymbol = Symbol('mySymbol');\nobj[mySymbol] = 123;\nconsole.log(obj); // { [Symbol(mySymbol)]: 123 }\nconsole.log(obj[mySymbol]); // 123\n")])])]),e("h2",{attrs:{id:"symbol-객체"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#symbol-객체","aria-hidden":"true"}},[o._v("#")]),o._v(" Symbol 객체")]),o._v(" "),e("p",[o._v("Symbol 객체는 프로퍼티와 메소드를 가지고 있다. Symbol 객체의 프로퍼티 중에 length와 prototype을 제외한 프로퍼티를 "),e("code",[o._v("Well-Known Symbol")]),o._v("이라 부른다.")]),o._v(" "),e("h3",{attrs:{id:"symbol-iterator"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#symbol-iterator","aria-hidden":"true"}},[o._v("#")]),o._v(" Symbol.iterator")]),o._v(" "),e("p",[o._v("Well-Known Symbol은 자바스크립트 엔진에 상수로 존재하며 자바스크립트 엔진은 Well-Known Symbol을 참조하여 일정한 처리를 한다. 예를 들어 어떤 객체가 Symbol.iterator를 프로퍼티 key로 사용한 메소드 가지고 있으면 자바스크립트 엔진은 이 객체가 이터레이션 프로토콜을 따르는 것으로 간주하고 이터레이터로 동작하도록 한다.\nSymbol.iterator를 프로퍼티 key로 사용하여 메소드를 구현하고 있는 빌트인 객체(빌트인 이터러블)는 아래와 같다. 아래의 객체들은 이터레이션 프로토콜을 준수하고 있으며 이터러이터를 반환한다.")]),o._v(" "),e("p",[e("strong",[o._v("Array")]),o._v("\nArray.prototype[Symbol.iterator]\n"),e("strong",[o._v("String")]),o._v("\nString.prototype[Symbol.iterator]\n"),e("strong",[o._v("Map")]),o._v("\nMap.prototype[Symbol.iterator]\n"),e("strong",[o._v("Set")]),o._v("\nSet.prototype[Symbol.iterator]\n"),e("strong",[o._v("DOM data structures")]),o._v("\nNodeList.prototype[Symbol.iterator] HTMLCollection.prototype[Symbol.iterator]\n"),e("strong",[o._v("arguments")]),o._v("\narguments[Symbol.iterator]")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("// 이터러블\n// Symbol.iterator를 프로퍼티 key로 사용한 메소드를 구현하여야 한다.\n// 배열에는 Array.prototype[Symbol.iterator] 메소드가 구현되어 있다.\nconst iterable = ['a', 'b', 'c'];\n\n// 이터레이터\n// 이터러블의 Symbol.iterator를 프로퍼티 key로 사용한 메소드는 이터레이터를 반환한다.\nconst iterator = iterable[Symbol.iterator]();\n\n// 이터레이터는 순회 가능한 자료 구조인 이터러블의 요소를 탐색하기 위한 포인터로서 value, done 프로퍼티를 갖는 객체를 반환하는 next() 함수를 메소드로 갖는 객체이다. 이터레이터의 next() 메소드를 통해 이터러블 객체를 순회할 수 있다.\nconsole.log(iterator.next()); // { value: 'a', done: false }\nconsole.log(iterator.next()); // { value: 'b', done: false }\nconsole.log(iterator.next()); // { value: 'c', done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n")])])]),e("h3",{attrs:{id:"symbol-for"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#symbol-for","aria-hidden":"true"}},[o._v("#")]),o._v(" Symbol.for")]),o._v(" "),e("p",[o._v("Symbol.for 메소드는 인자로 전달받은 문자열을 키로 사용하여 Symbol 값들이 저장되어 있는 전역 Symbol 레지스트리에서 해당 키와 일치하는 저장된 Symbol 값을 검색한다. 이때 검색에 성공하면 검색된 Symbol 값을 반환하고, 검색에 실패하면 새로운 Symbol 값을 생성하여 해당 키로 전역 Symbol 레지스트리에 저장한 후, Symbol 값을 반환한다.")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("// 전역 Symbol 레지스트리에 foo라는 키로 저장된 Symbol이 없으면 새로운 Symbol 생성\nconst s1 = Symbol.for('foo');\n// 전역 Symbol 레지스트리에 foo라는 키로 저장된 Symbol이 있으면 해당 Symbol을 반환\nconst s2 = Symbol.for('foo');\n\nconsole.log(s1 === s2); // true\n")])])]),e("p",[o._v("Symbol 함수는 매번 다른 Symbol 값을 생성하는 것에 반해, Symbol.for 메소드는 하나의 Symbol을 생성하여 여러 모듈이 키를 통해 같은 Symbol을 공유할 수 있다.\nSymbol.for 메소드를 통해 생성된 Symbol 값은 반드시 키를 갖는다. 이에 반해 Symbol 함수를 통해 생성된 Symbol 값은 키가 없다.")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v("const shareSymbol = Symbol.for('myKey');\nconst key1 = Symbol.keyFor(shareSymbol);\nconsole.log(key1); // myKey\n\nconst unsharedSymbol = Symbol('myKey');\nconst key2 = Symbol.keyFor(unsharedSymbol);\nconsole.log(key2); // undefined\n")])])])])}],!1,null,null,null);t.default=a.exports}}]);